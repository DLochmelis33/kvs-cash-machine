\hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable}{}\doxysection{kvs\+::storage\+\_\+hash\+\_\+table\+::Storage\+Hash\+Table Class Reference}
\label{classkvs_1_1storage__hash__table_1_1StorageHashTable}\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}


The hash table that is stored on disk.  




{\ttfamily \#include $<$Storage\+Hash\+Table.\+h$>$}



Collaboration diagram for kvs\+::storage\+\_\+hash\+\_\+table\+::Storage\+Hash\+Table\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=240pt]{classkvs_1_1storage__hash__table_1_1StorageHashTable__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_a2fe1a149b5101463bd8dd6a32a7db013}{Storage\+Hash\+Table}} (\mbox{\hyperlink{classkvs_1_1utils_1_1ByteArray}{Byte\+Array}} serialized\+Storage\+Hash\+Table)
\begin{DoxyCompactList}\small\item\em Deserialize a \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable}{Storage\+Hash\+Table}} from serialized\+Storage\+Hash\+Table. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_a6f3b13f043ee776925a57eb133007337}{Storage\+Hash\+Table}} (size\+\_\+t size) noexcept
\begin{DoxyCompactList}\small\item\em Construct a new empty \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable}{Storage\+Hash\+Table}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classkvs_1_1utils_1_1ByteArray}{Byte\+Array}} \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_a0400640000ce3beba91d7bd4aa9a125b}{serialize\+To\+Byte\+Array}} () const noexcept
\begin{DoxyCompactList}\small\item\em Serialize the table into a Byte\+Array. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classkvs_1_1utils_1_1Ptr}{Ptr}} \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_a66bf7d8b67788955a0b31e559a5bc8f7}{get}} (\mbox{\hyperlink{classkvs_1_1utils_1_1Key}{Key}} key) const noexcept
\begin{DoxyCompactList}\small\item\em Find the Ptr associated with the key. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_aef861454194dfb5fb2297f47e8d6d27b}{put}} (\mbox{\hyperlink{structkvs_1_1utils_1_1Entry}{Entry}} entry) noexcept
\begin{DoxyCompactList}\small\item\em Put an Entry into the table. \end{DoxyCompactList}\item 
const std\+::vector$<$ \mbox{\hyperlink{structkvs_1_1utils_1_1Entry}{Entry}} $>$ \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_a72eeb03eceaf5ee75d0cbec4a5eb44a8}{get\+Entries}} () const noexcept
\begin{DoxyCompactList}\small\item\em Get all entries present in the map. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_ad8b2438df122755c82222352e3e9743c}{expand}} ()
\begin{DoxyCompactList}\small\item\em Expand the map to twice its current capacity. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \mbox{\hyperlink{structkvs_1_1utils_1_1Entry}{Entry}} $>$ \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_a09e4ba7b9e6417d93926b32df2b3495a}{data}}
\item 
std\+::size\+\_\+t \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable_ae20d9b7e7e77cf76e364a1d17fc73a44}{used\+Size}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The hash table that is stored on disk. 

Operates in RAM, so can be used with any kind of storage via serializing. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_a2fe1a149b5101463bd8dd6a32a7db013}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_a2fe1a149b5101463bd8dd6a32a7db013}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!StorageHashTable@{StorageHashTable}}
\index{StorageHashTable@{StorageHashTable}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{StorageHashTable()}{StorageHashTable()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::\+Storage\+Hash\+Table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classkvs_1_1utils_1_1ByteArray}{Byte\+Array}}}]{serialized\+Storage\+Hash\+Table }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



Deserialize a \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable}{Storage\+Hash\+Table}} from serialized\+Storage\+Hash\+Table. 


\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classkvs_1_1KVSException}{KVSException}}} & if the data is corrupted \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_a6f3b13f043ee776925a57eb133007337}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_a6f3b13f043ee776925a57eb133007337}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!StorageHashTable@{StorageHashTable}}
\index{StorageHashTable@{StorageHashTable}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{StorageHashTable()}{StorageHashTable()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::\+Storage\+Hash\+Table (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}, {\ttfamily [noexcept]}}



Construct a new empty \mbox{\hyperlink{classkvs_1_1storage__hash__table_1_1StorageHashTable}{Storage\+Hash\+Table}}. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_ad8b2438df122755c82222352e3e9743c}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_ad8b2438df122755c82222352e3e9743c}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!expand@{expand}}
\index{expand@{expand}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{expand()}{expand()}}
{\footnotesize\ttfamily void kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::expand (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Expand the map to twice its current capacity. 

Needs to be called once the number of elements exceeds capacity $\ast$ a predefined constant. Only works one time; calling this method a second time causes a SHARD\+\_\+\+OVERFLOW typed \mbox{\hyperlink{classkvs_1_1KVSException}{KVSException}}.


\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classkvs_1_1KVSException}{KVSException}}} & if the table is already expanded \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_a66bf7d8b67788955a0b31e559a5bc8f7}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_a66bf7d8b67788955a0b31e559a5bc8f7}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!get@{get}}
\index{get@{get}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classkvs_1_1utils_1_1Ptr}{Ptr}} kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::get (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classkvs_1_1utils_1_1Key}{Key}}}]{key }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}



Find the Ptr associated with the key. 

\begin{DoxyReturn}{Returns}
The requested Ptr or nothing, if no Entry with given Key is present. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_a72eeb03eceaf5ee75d0cbec4a5eb44a8}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_a72eeb03eceaf5ee75d0cbec4a5eb44a8}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!getEntries@{getEntries}}
\index{getEntries@{getEntries}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{getEntries()}{getEntries()}}
{\footnotesize\ttfamily const std\+::vector$<$ \mbox{\hyperlink{structkvs_1_1utils_1_1Entry}{Entry}} $>$ kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::get\+Entries (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}



Get all entries present in the map. 

Used during rebuilding.

\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Entry$>$ 
\end{DoxyReturn}
\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_aef861454194dfb5fb2297f47e8d6d27b}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_aef861454194dfb5fb2297f47e8d6d27b}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!put@{put}}
\index{put@{put}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{put()}{put()}}
{\footnotesize\ttfamily void kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::put (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structkvs_1_1utils_1_1Entry}{Entry}}}]{entry }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Put an Entry into the table. 

\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_a0400640000ce3beba91d7bd4aa9a125b}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_a0400640000ce3beba91d7bd4aa9a125b}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!serializeToByteArray@{serializeToByteArray}}
\index{serializeToByteArray@{serializeToByteArray}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{serializeToByteArray()}{serializeToByteArray()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classkvs_1_1utils_1_1ByteArray}{Byte\+Array}} kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::serialize\+To\+Byte\+Array (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}



Serialize the table into a Byte\+Array. 



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_a09e4ba7b9e6417d93926b32df2b3495a}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_a09e4ba7b9e6417d93926b32df2b3495a}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!data@{data}}
\index{data@{data}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{data}{data}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{structkvs_1_1utils_1_1Entry}{Entry}}$>$ kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::data\hspace{0.3cm}{\ttfamily [private]}}

\mbox{\Hypertarget{classkvs_1_1storage__hash__table_1_1StorageHashTable_ae20d9b7e7e77cf76e364a1d17fc73a44}\label{classkvs_1_1storage__hash__table_1_1StorageHashTable_ae20d9b7e7e77cf76e364a1d17fc73a44}} 
\index{kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}!usedSize@{usedSize}}
\index{usedSize@{usedSize}!kvs::storage\_hash\_table::StorageHashTable@{kvs::storage\_hash\_table::StorageHashTable}}
\doxysubsubsection{\texorpdfstring{usedSize}{usedSize}}
{\footnotesize\ttfamily std\+::size\+\_\+t kvs\+::storage\+\_\+hash\+\_\+table\+::\+Storage\+Hash\+Table\+::used\+Size\hspace{0.3cm}{\ttfamily [private]}}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\mbox{\hyperlink{StorageHashTable_8h}{Storage\+Hash\+Table.\+h}}\item 
src/\mbox{\hyperlink{StorageHashTable_8cpp}{Storage\+Hash\+Table.\+cpp}}\end{DoxyCompactItemize}
